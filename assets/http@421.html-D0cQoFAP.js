const t=JSON.parse('{"key":"v-039b0d2f","path":"/posts/dev/http@421.html","title":"记一次http@421状态码的排查情况","lang":"zh-CN","frontmatter":{"date":"2023-12-15T00:00:00.000Z","icon":"note","star":true,"category":["dev"],"tag":["status@421","http"],"description":"记一次http@421状态码的排查情况 后台返回421状态码时，浏览器底层会自动重发一次相同的请求 F12查看只有一次请求，前端请求的返回也只有一条 通过抓包软件或者ng后台日志可以确认浏览器确认发了2条相同的请求 1. 过程 一次日常版本测试中，测试同事反馈某一场景下后台日志收到:接口A有2条相同的请求日志，而接口B只有一条请求日志。 1.1. 排查 是不是对应的请求输出日志有两条 不是 是不是接口A跨域的option请求 不是，这个接口虽然跨域，但是因为是简单请求，所以没有option请求。 是不是前端代码逻辑问题 不是，通过F12调试看网络请求只有一个请求。对应的业务代码也只收到一次回调。 通过抓包软件查看，确实有两次相同的接口A请求 该接口http@200成功时的日志情况 接口A只有一条请求记录。 查看http规范中421状态码的说明，同时找后台同事切换到其他错误码423验证，只有一条请求记录。 老机型的部分浏览器验证 http@421只发了一次请求。","head":[["meta",{"property":"og:url","content":"https://justdoless.cn/posts/dev/http@421.html"}],["meta",{"property":"og:site_name","content":"blog"}],["meta",{"property":"og:title","content":"记一次http@421状态码的排查情况"}],["meta",{"property":"og:description","content":"记一次http@421状态码的排查情况 后台返回421状态码时，浏览器底层会自动重发一次相同的请求 F12查看只有一次请求，前端请求的返回也只有一条 通过抓包软件或者ng后台日志可以确认浏览器确认发了2条相同的请求 1. 过程 一次日常版本测试中，测试同事反馈某一场景下后台日志收到:接口A有2条相同的请求日志，而接口B只有一条请求日志。 1.1. 排查 是不是对应的请求输出日志有两条 不是 是不是接口A跨域的option请求 不是，这个接口虽然跨域，但是因为是简单请求，所以没有option请求。 是不是前端代码逻辑问题 不是，通过F12调试看网络请求只有一个请求。对应的业务代码也只收到一次回调。 通过抓包软件查看，确实有两次相同的接口A请求 该接口http@200成功时的日志情况 接口A只有一条请求记录。 查看http规范中421状态码的说明，同时找后台同事切换到其他错误码423验证，只有一条请求记录。 老机型的部分浏览器验证 http@421只发了一次请求。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-11T14:43:38.000Z"}],["meta",{"property":"article:author","content":"justdoless"}],["meta",{"property":"article:tag","content":"status@421"}],["meta",{"property":"article:tag","content":"http"}],["meta",{"property":"article:published_time","content":"2023-12-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-11T14:43:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"记一次http@421状态码的排查情况\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-11T14:43:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"justdoless\\",\\"url\\":\\"https://justdoless.cn\\",\\"email\\":\\"justdoless.com@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 过程","slug":"_1-过程","link":"#_1-过程","children":[{"level":3,"title":"1.1. 排查","slug":"_1-1-排查","link":"#_1-1-排查","children":[]},{"level":3,"title":"1.2. 确认","slug":"_1-2-确认","link":"#_1-2-确认","children":[]}]},{"level":2,"title":"2. 参考","slug":"_2-参考","link":"#_2-参考","children":[]}],"git":{"createdTime":1704984218000,"updatedTime":1704984218000,"contributors":[{"name":"xgwang","email":"xgwang@sysnew.com","commits":1}]},"readingTime":{"minutes":1.39,"words":416},"filePathRelative":"posts/dev/http@421.md","localizedDate":"2023年12月15日","excerpt":"<h1> 记一次http@421状态码的排查情况</h1>\\n<blockquote>\\n<ol>\\n<li>后台返回421状态码时，浏览器底层会自动重发一次相同的请求</li>\\n<li>F12查看只有一次请求，前端请求的返回也只有一条</li>\\n<li>通过抓包软件或者ng后台日志可以确认浏览器确认发了2条相同的请求</li>\\n</ol>\\n</blockquote>\\n<h2> 1. 过程</h2>\\n<p>一次日常版本测试中，测试同事反馈某一场景下后台日志收到:接口A有2条相同的请求日志，而接口B只有一条请求日志。</p>\\n<h3> 1.1. 排查</h3>\\n<ol>\\n<li>是不是对应的请求输出日志有两条\\n<ol>\\n<li>不是</li>\\n</ol>\\n</li>\\n<li>是不是接口A跨域的option请求\\n<ol>\\n<li>不是，这个接口虽然跨域，但是因为是简单请求，所以没有option请求。</li>\\n</ol>\\n</li>\\n<li>是不是前端代码逻辑问题\\n<ol>\\n<li>不是，通过F12调试看网络请求只有一个请求。对应的业务代码也只收到一次回调。</li>\\n<li>通过抓包软件查看，确实有两次相同的接口A请求</li>\\n</ol>\\n</li>\\n<li>该接口http@200成功时的日志情况\\n<ol>\\n<li>接口A只有一条请求记录。</li>\\n<li>查看http规范中421状态码的说明，同时找后台同事切换到其他错误码423验证，只有一条请求记录。</li>\\n</ol>\\n</li>\\n<li>老机型的部分浏览器验证\\n<ol>\\n<li>http@421只发了一次请求。</li>\\n</ol>\\n</li>\\n</ol>","copyright":{"author":"justdoless.com@gmail.com"},"autoDesc":true}');export{t as data};
